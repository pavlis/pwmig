#include "gclgrid.h"
#include "dmatrix.h"
#include "seispp.h"
#include "ray1d.h"
#include "pf.h"
using namespace std;
using namespace SEISPP;
#include "pwmig.h"
/* Used below to copy a dmatrix defining a ray path into the ith, jth 
grid line (vertical-like ) of the GCCgrid3d object raygrid.  
It does check to verify that dimensions are consistent.
If the path is longer or exactly matches the grid dimension
this function returns 0.  If the path is short the raygrid is
generated by projecting along a straight line from the last valid
point in path (last meaning the deepest).  The function returns
a -1 if the input path is invalid and impossible to work with.
This means simply that the path matrix does not have at least 
2 data points (the minimum needed for a straight line projection).
This was intentionally not done through an exception mechanism
as the books all say exceptions slow function calls.  Since this
is a fairly low level routine limited in scope to this file this
is a preferred mechanism.  For the purest, get a life.

A major complicating factor here is that a GCLgrid insists that
the gridlines run in an upward sequence to maintain a right handed
coordinate system in finite element style boxes.  This means the
path needs to be inverted (first column of path is placed at 
the n3-1 position in the raygrid).  
*/
int copy_path(dmatrix& ray,GCLgrid3d& raygrid,int i, int j)
{
	int k,kk;
	int status;
	int path_length=ray.columns();
	if(path_length<2) return(-1);
	if(path_length>=raygrid.n3)
	{
		for(k=0,kk=raygrid.n3-1;k<raygrid.n3;++k,--kk)
		{
			if(k>=path_length) break;
			raygrid.x1[i][j][kk]=ray(0,k);
			raygrid.x2[i][j][kk]=ray(1,k);
			raygrid.x3[i][j][kk]=ray(2,k);
		}
		status=0;
	}
	else
	{
		// this block handles short input path with
		// a linear projection from the deepest point.
		// Done by creating a new temporary dmatrix 
		// with the extended path and running the 
		// same algorithm as above.
		double dx1,dx2,dx3;
		dx1=ray(0,path_length-1)-ray(0,path_length-2);
		dx2=ray(1,path_length-1)-ray(1,path_length-2);
		dx3=ray(2,path_length-1)-ray(2,path_length-2);
		dmatrix extendedray(3,raygrid.n3);
		for(k=0;k<path_length;++k)
			for(int l=0;l<3;++l)
				extendedray(l,k)=ray(l,k);
		for(k=path_length;k<raygrid.n3;++k)
		{
			extendedray(0,k)=extendedray(0,k-1)+dx1;
			extendedray(1,k)=extendedray(1,k-1)+dx2;
			extendedray(2,k)=extendedray(2,k-1)+dx3;
		}
		for(k=0,kk=raygrid.n3-1;k<raygrid.n3;++k,--kk)
		{
			raygrid.x1[i][j][kk]=extendedray(0,k);
			raygrid.x2[i][j][kk]=extendedray(1,k);
			raygrid.x3[i][j][kk]=extendedray(2,k);

		}
		status = +1;
	}
	return(status);
}


/* This function acts like a constructor, but it isn't made an explicit part of the object
definition because it is a special construction used for this program.  

Arguments:
	fixed_u_mode - boolean.  If true, use one ray for all points.
		if false, trace a new ray for each grid point.  Former is 
		faster, but a poor approximation for large arrays and
		relatively close sources.
	parent - 2d surface GCLgrid of pseudostation grid points 
	u - slowness vector used to generate this ray grid (note for large grids this points in
		different directions at different points even though the vector is fixed)
		(Note used even when fixed_u_mode is false to establish
		grid dimensions )
	h - Hypocenter object with handle to compute slowness vecotr
		at each grid point (ignored if fixed_u_mode is true).
	vmod - 1d velocity model used for ray tracing 
	zmax, tmax - depth, time maxima used to define ray trace limits.

Note that the number of points that define each ray path is set by the ray tracing.  The
same ray, in fact, is used for all elements but the projection is spatially dependent because
of earth curvature and geographical coordinate conventions on how slowness vector are 
traditionally defined.  This algorithm is a bit at odds with the gclgrid model where the
object is to reduce artifacts for where on earth the grid happened to be positioned.  This 
approach may cause problems for grids near the pole and will definitely not work for a grid
that spans the pole.  Since neither is likely in the near future this seems a minor 
concession to simplicity.  

The number of points in n3 direction is determined by the ray tracing and is implicitly 
returned as the n3 variable in the newly created GCLgrid3d object.  Note carefully that
this function acts like new and the object must eventually be deleted explicitly.  

It is also VERY important to recognize this constructor produces ray grids that 
are oriented from the bottom up.  This is useful to keep the set of basis vectors
at all points right handed.  


Author:  Gary Pavlis
*/  


GCLgrid3d *Build_GCLraygrid(bool fixed_u_mode,
		GCLgrid& parent,
		SlownessVector u, Hypocenter h,
		VelocityModel_1d& vmod,
		double zmax, double tmax, double dt)
{
	int i,j;
	double umag, theta;  // used many times so we make temporaries of these
	if(fixed_u_mode)
	{
		umag = u.mag();
		theta = u.baz();
	}
	// First trace the basic ray object that will be projected.  This gets dimensions.
	RayPathSphere base_ray(vmod, u.mag(), zmax, tmax, dt, "t");

	// call the simple, parameterized GCLgrid constructor that allocs space but has no content
	GCLgrid3d *rgptr = new GCLgrid3d(parent.n1, parent.n2, base_ray.npts);
	GCLgrid3d& raygrid = *rgptr;
	// clone these parent grid variable
	raygrid.name=parent.name;
	raygrid.lat0=parent.lat0;
	raygrid.lon0=parent.lon0;
	raygrid.r0=parent.r0;
	raygrid.azimuth_y=parent.azimuth_y;
	raygrid.dx1_nom=parent.dx1_nom;
	raygrid.dx2_nom=parent.dx2_nom;
	raygrid.n1=parent.n1;
	raygrid.n2=parent.n2;
	raygrid.i0=parent.i0;
	raygrid.j0=parent.j0;
	/*  k0 must be set to the point at the earth's surface.  This is necesary
	to set the transformation at this point to keep all grids consistent. 
	The ray bottom will depend on the slowness vector */
	raygrid.k0 = base_ray.npts - 1;  // earth's surface or this will be
					// inconsistent with lat0,lon0
	// need to explicitly set the transformation matrix like this 
	// as it can only be set through this mechanism
	raygrid.set_transformation_matrix();
	//
	// now start filling up the grid with the cartesian points
	//
	dmatrix *path;
	for(i=0;i<parent.n1;++i)
		for(j=0;j<parent.n2;++j)
		{
			int ierr;
			try {
			    if(fixed_u_mode)
			    {
				path = GCLgrid_Ray_project(parent,base_ray, 
					theta, i,j);
			    }
			    else
			    {
				SlownessVector uij=h.pslow(parent.lat(i,j),
					parent.lon(i,j),0.0);
				umag=uij.mag();
				theta=uij.baz();
				RayPathSphere ray(vmod, uij.mag(), zmax, tmax, dt, "t");
				path = GCLgrid_Ray_project(parent,ray, 
					theta, i,j);

			    }
			    ierr=copy_path(*path,raygrid,i,j);
/*
cerr << "(i,j)="<<i<<","<<j<<" r difference = "
		<< raygrid.r(i,j,raygrid.n3-1) - parent.r(i,j)
		<< endl;
*/
			    delete path;
			    if(ierr<0) 
			    {
				cerr << "copy_path:  length error"<<endl
					<< "Passed a path of length "
					<< path->columns()<<endl
					<< "Cannot continue"<<endl;
				exit(-1);
			    }

			}
			catch (GCLgrid_error& err)
			{
				err.log_error();
				cerr << "Cannot continue" <<endl;
				exit(-1);
			}
		}


	// Before we return we have to recompute the grid extents.
	raygrid.compute_extents();

	return(rgptr);

}
